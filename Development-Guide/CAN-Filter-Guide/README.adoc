= CAN Message Filter Guide

NOTE: This is a basic guide to making a CAN message filter

==== Introduction
The two main components of a filter are an ID and a Mask.
The ID will be the unique identifier for the message you are looking for, and the Mask will determine which bits of the ID are important to sift through (this makes the proccess much more efficient and flexible). 

IMPORTANT: A Mask must be able to adapt to future additions to a CAN network. It must be made *as tight as possible for longevity*.

There is no set order to follow the steps, but to get started follow the steps below until you are comfortable.
Another tip is to convert the hex format into binary format, determine the ID and Mask, and then convert those back into hex.

==== Steps

. Determine the ID
.. The ID will be the unique identifier for the message(s) that you are trying to receive
.. The ID should be very specific and contain the important bits that will be compared to the incoming message. 
The greater the variery of addresses, the more flexible your ID will be to accommodate the variety of incoming messages.
.. For example, If you are looking for a message from a system that sends out messages with address 0b0000_1111(0x0F) then you want your ID to look like 0b0000_1111(0x0F) because there is only one type of address you want to receive.
.. For example, If you are looking for a message from a system that sends out messages with addresses 0b0001_0001, 0b0001_0010, and 0b0001_0011 (0x11, 0x12, and 0x13) then you want your ID to look like 0b0001_0000 (0x10) because the last two bits do not matter. 
You could choose 0x11 or 0x15 for your ID or any number for the last hex digit, and it will work regardless. 
It is your mask that determines which bits are important to compare.

. Determine the Mask
.. The Mask will determine which bits in the address of the message and which bits in the ID are important to compare. It compares the messages by using 1s and 0s. You use 1s for the bits that you want to compare and you use 0s for the bits that do not matter. 
... For example, 0b0000_0001 only compares the first bit (bit 0) while 0b1111_1111 compares every bit
.. The Mask should be as tight as possible so that no other messages from other addresses except for the one(s) that you want are filtered in. 
It should also be made for longevity as more systems are prone to be added. 
Like the ID, the greater the variety of addresses, the more flexible your Mask should be to be able to accommodate the variety.
... For example, If you are looking for a message from a system that sends out messages with address 0b0000_1111 (0x0F), we know from above that your ID will be 0b0000_1111 (0x0F), but your mask will be 0b1111_1111(0xFF). 
This will compare every single bit of the ID and the address coming through so that only messages from that single address will be filtered through.
... For example, If you are looking for a message from a system that sends out messages with addresses 0b0001_0001, 0b0001_0010, and 0b0001_0011 (0x11, 0x12, and 0x13), we know from above that your ID will be 0b0001_0000(0x010), but your Mask will be 0b1111_1100(0xFC) to compare ever bit except the last two because they don't mattter.

Overall, based on the above steps you can make a table to see the incoming message(s) you are comparing, a valid ID, and a valid Mask to make the problem much easier to solve

*Example Table (From first Mask example)*
[options = "header, footer"]
|=======
|Address Wanted |ID |Mask
|0x00F |0x00F |0xFFF
|=======



==== Examples
Now that you have a basic idea of how to make a CAN filter, try the following two exercises
----
You have a system that contains 2 systems: SYS1 and SYS2. 
SYS1 sends messages with the address 0x71, and SYS2 sends messages with addresses 0x80 to 0x8F. 
Write a filter for SYS2.

Answer - ID: 0x80, Mask: 0xF0
----

----
Write a filter for the Lights Board. You can reference the Communcations Protocol.

Answer - ID: 0x700, Mask: 0xFFE
----

