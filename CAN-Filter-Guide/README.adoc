== CAN Message Filter Guide
----
This is a basic guide to making a CAN message filter
----

==== Main Idea
The two main components of a filter are an ID and a Mask. The ID will be the unique identifier for the message you are looking for, and the Mask will determine which bits of the ID are important to sift through (this makes the proccess much more efficient and flexible). 

IMPORTANT: A Mask must be able to adapt to future additions to a CAN network. It must be made *as tight as possible for longevity*.

There is no set order to follow the steps, but to get started follow the steps below until you are comfortable. Another tip is to convert the hex numbers into binary numbers, determine the ID and Mask, and then convert those back into hex.

.*Steps*
. Determine the ID
.. The ID will be the unique identifier for the message(s) that you are trying to receive
.. The ID should be very specific and contain the important bits that will be compared to the incoming message. The greater the variery of addresses, the more flexible your ID will be to accomodate the the variety
.. For example: If you are looking for a message from a system that sends out messages with address 0b0000_0000_1111(0x00F) then you want your ID to look like 0b0000_0000_1111(0x00F) because there is only one type of address you are getting
.. For example: If you are looking for a message from a system that sends out messages with addresses 0b0000_0001_0001, 0b0000_0001_0010, and 0b0000_0001_0011 (0x011, 0x012, and 0x013) then you want your ID to look like 0b0000_0001_0000 (0x010) because the last two bits do not matter. You could choose 0x011 or 0x015 for your ID or any number for the last hex digit, and it will work regardless. It is your mask that determines which bits are important to compare.
. Determine the Mask
.. The Mask will determine which bits in the address of the message and which bits in the ID are important to compare
.. The Mask should be as tight as possible so that no other messages from other addresses except for the one(s) that you want are filtered in. It should also be made for longevity as more systems are prone to be added. Like the ID, the greater the variety of addresses, the more flexible your Mask will be to accomodate the variety.
.. For example: If you are looking for a message from a system that sends out messages with address 0b0000_0000_1111 (0x00F), we know from above that your ID will be 0b0000_0000_1111 (0x00F), but your mask will be 0b1111_1111_1111(0xFFF). This will compare every single bit of the ID and the address coming through so that only messages from that single address will be filtered through.
..For example: If you are looking for a message from a system that sends out messages with addresses 0b0000_0001_0001, 0b0000_0001_0010, and 0b0000_0001_0011 (0x011, 0x012, and 0x013), we know from above that your ID will be 0b0000_0001_0000(0x010), but your Mask will be 0b1111_1111_1100(0xFFC) to compare ever bit except the last two because they don't matter as much.


==== Practice 
Now that you have a basic idea of how to make a CAN filter, try the following two excercises
----
You have a system that contains 2 systems: SYS1 and SYS2. 
SYS1 sends messages with the address 0x071, and SYS2 sends messages with addresses 0x080 to 0x08F. 
Write a filter for SYS2.

Answer - ID: 0x080, Mask: 0xFF0
----

----
Write a filter for the Lights Board. You can reference the Communcations Protocol.

Answer - ID: 0x700, Mask: 0xFFE
----

